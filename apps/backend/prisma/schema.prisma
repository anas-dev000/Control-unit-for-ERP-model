// Prisma Schema for Multi-Tenant Accounting System
// Database: PostgreSQL with Row-Level Isolation Strategy

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// TENANT MODEL
// ============================================
model Tenant {
  id        String    @id @default(uuid())
  name      String
  domain    String?   @unique
  settings  Json?     @db.JsonB
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  users     User[]
  customers Customer[]
  invoices  Invoice[]
  payments  Payment[]

  @@index([deletedAt])
  @@map("tenants")
}

// ============================================
// USER MODEL
// ============================================
model User {
  id           String    @id @default(uuid())
  tenantId     String
  email        String
  passwordHash String
  firstName    String
  lastName     String
  role         Role      @default(USER)
  isActive     Boolean   @default(true)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  deletedAt    DateTime?
  createdBy    String?

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, email], name: "tenantId_email")
  @@index([tenantId, isActive])
  @@index([email])
  @@map("users")
}

enum Role {
  ADMIN
  MANAGER
  USER
}

// ============================================
// CUSTOMER MODEL
// ============================================
model Customer {
  id           String    @id @default(uuid())
  tenantId     String
  name         String
  email        String?
  phone        String?
  address      String?
  taxNumber    String?
  creditLimit  Decimal   @default(0) @db.Decimal(12, 2)
  paymentTerms Int       @default(30) // Days
  isActive     Boolean   @default(true)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  deletedAt    DateTime?
  createdBy    String?

  tenant   Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  invoices Invoice[]
  payments Payment[]

  @@index([tenantId, isActive])
  @@index([tenantId, name])
  @@unique([tenantId, name], name: "tenantId_name")
  @@unique([tenantId, email], name: "tenantId_email")
  @@map("customers")
}

// ============================================
// INVOICE MODEL
// ============================================
model Invoice {
  id            String        @id @default(uuid())
  tenantId      String
  customerId    String
  invoiceNumber String
  date          DateTime      @default(now())
  dueDate       DateTime
  subtotal      Decimal       @db.Decimal(12, 2)
  taxRate       Decimal       @default(0.15) @db.Decimal(5, 4)
  taxAmount     Decimal       @db.Decimal(12, 2)
  total         Decimal       @db.Decimal(12, 2)
  paidAmount    Decimal       @default(0) @db.Decimal(12, 2)
  status        InvoiceStatus @default(DRAFT)
  notes         String?       @db.Text
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  deletedAt     DateTime?
  createdBy     String?

  tenant   Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customer Customer      @relation(fields: [customerId], references: [id], onDelete: Restrict)
  items    InvoiceItem[]
  payments Payment[]

  @@unique([tenantId, invoiceNumber], name: "tenantId_invoiceNumber")
  @@index([tenantId, customerId, status])
  @@index([tenantId, date])
  @@index([tenantId, status, dueDate])
  @@map("invoices")
}

enum InvoiceStatus {
  DRAFT
  SENT
  PAID
  PARTIAL
  OVERDUE
  CANCELLED
}

// ============================================
// INVOICE ITEM MODEL
// ============================================
model InvoiceItem {
  id          String  @id @default(uuid())
  invoiceId   String
  description String
  quantity    Decimal @db.Decimal(10, 2)
  unitPrice   Decimal @db.Decimal(12, 2)
  amount      Decimal @db.Decimal(12, 2)
  sortOrder   Int     @default(0)

  invoice Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  @@index([invoiceId])
  @@map("invoice_items")
}

// ============================================
// PAYMENT MODEL
// ============================================
model Payment {
  id          String        @id @default(uuid())
  tenantId    String
  customerId  String
  invoiceId   String?
  amount      Decimal       @db.Decimal(12, 2)
  paymentDate DateTime      @default(now())
  method      PaymentMethod
  reference   String?
  notes       String?       @db.Text
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  deletedAt   DateTime?
  createdBy   String?

  tenant   Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customer Customer  @relation(fields: [customerId], references: [id], onDelete: Restrict)
  invoice  Invoice?  @relation(fields: [invoiceId], references: [id], onDelete: SetNull)

  @@index([tenantId, customerId])
  @@index([tenantId, paymentDate])
  @@index([invoiceId])
  @@map("payments")
}

enum PaymentMethod {
  CASH
  BANK_TRANSFER
  CREDIT_CARD
  CHECK
  OTHER
}
